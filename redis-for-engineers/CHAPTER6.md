## 메모
- 메시지 큐와 이벤트 스트림의 가장 큰 차이는 이벤트 소비의 범위 (single or multiple)
- 메시지 큐의 메시지는 소비되면 바로 삭제되지만 이벤트 스트림은 소비자가 복제하여 가져가기때문에 소비 후 삭제되지 않음
- 소비 후 삭제 여부는 이벤트 구독 시점에 따라 소비 가능한 데이터의 범위를 한정함
- 레디스 클러스터
    - slot = CRC16(key) % 16384
    - 모든 키는 하나의 슬롯에 종속됨
    - 하나의 슬롯은 하나의 노드에서 관리
    - 하지만 복제본으로 읽기 전용인 슬레이브 노드를 지정할 수 있음
    - 마스터 노드에 장애가 발생할 경우 슬레이브 노드가 마스터 노드로 승격
    - 슬레이브 노드는 읽기 전용이므로 쓰기는 마스터 노드에서만 이루어짐
- 블로킹 커맨드
    - 레디스는 싱글 스레드 이지만 블로킹 커맨드를 사용해도 다른 클라이언트의 요청을 처리할 수 있는 이유는 I/O 멀티 플렉싱으로 동작하기 때문임
    - 실제로 블로킹되어 특정 시간동안 기다리는 것은 소켓임
    - I/O 멀티 플렉싱으로 현재 데이터 처리할 준비가 된 소켓만 CPU를 사용하여 레디스 서버에서 처리
    - 그래서 블로킹 명령어를 사용해도 다른 클라이언트의 명령어 처리가 가능
- I/O 멀티 플렉싱
    - 커널이 동시에 여러 I/O 이벤트를 감지하여 그 중 준비가된 이벤트를 처리하여 CPU를 효율적으로 사용하기 위한 기술
    - 하나의 프로세스나 쓰레드에서 여러 소켓, 파일 핸들이 가능한 이유
    - epoll, kqueue
- 소비자 그룹
    - 카프카 파티션과 소비자를 1:1로 연결시켜주는 것이 소비자 그룹
    - 레디스의 소비자그룹은 같은 채널을 구독하지만 같은 그룹내의 다른 소비자가 읽지 않은 데이터만 가져감
    - 레디스에선 소비자 그룹이 다르면 같은 채널의 메시지를 같이 소비할 수 있으며 반대로 같은 소비자 그룹이면 그룹 내 다른 소비자들은 같은 메시지를 읽을 수 없음
- 보류 리스트
    - 소비자 그룹이 읽고 있지만 아직 ack를 보내지 않은 상태의 메시지
    - 각 소비자마다 보류리르스를 갖고 있음
    - 장애가 일어난 경우 해당 소비자 보류 리스트에 메시지가 있는지 확인하면 처리되지 않은 메시지를 알 수 있음


## 개인적인 생각
레디스 스트림은 카프카와 비슷하면서도 다르다. 
푸쉬 알림 같은 서비스에서는 레디스 스트림이 유용할 것 같긴한데, 소비된 메시지 삭제가 너무 치명적이다. 하나의 서비스에서 메시지 브로커를 두 개 유지할 경우 유지보수 비용이 올라갈텐데 메시지 저장까지 가능한 카프카가 아닌 레디스를 쓸 이유가 있는지 잘 모르겠다. 